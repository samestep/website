<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/png" href="/icon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&amp;family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&amp;display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/monokai.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"
    />
    <link rel="stylesheet" href="/blog.css" />
    <title>
      Parameters and binding forms should be mutually recursive | Sam Estep
    </title>
  </head>
  <body>
    <main>
      <h1>Parameters and binding forms should be mutually recursive</h1>
      <p>
        <em>by <a href="/">Sam Estep</a>, unpublished</em>
      </p>
      <div id="body">
        <div>
          <p>
            <strong>tl;dr:</strong> I want programming languages to let me write
            code like the following. Every language I'm aware of makes this more
            painful than it should be in either the function definition, or the
            function call, or both:
          </p>
          <pre><code>fn transport(
  (start: Timestamp, end: Timestamp),
  foo: FooId,
  {
    bar: BarId,
    person = { name = who: String, phone: String },
    options = { fragile: Boolean, window: HalfDay },
  },
) {
  do_stuff(who, foo);
  more_stuff(phone, end, window);
  other_things(start, fragile, bar);
}

let bar = something();
transport(
  (iso(&quot;2025-09-03T09:00:00Z&quot;), iso(&quot;2025-09-03T11:00:00Z&quot;)),
  foo123,
  {
    bar,
    person = { name = &quot;Alex Smith&quot;, phone = &quot;+1 (555) 555-5555&quot; },
    options = { fragile = true, window = HalfDay.PM },
  },
)
</code></pre>
          <p>Put simply:</p>
          <ul>
            <li>
              I want to be able to define a function whose parameters are
              aggregates, and simultaneously destructure those aggregates,
              binding pieces of them to local values.
            </li>
            <li>
              I want to be able to define the function to accept parameters
              either positionally (i.e. like a tuple) or by name (i.e. like a
              record or struct) with minimal boilerplate.
            </li>
            <li>
              I want to be able to nest these aggregates without having to
              <ul>
                <li>
                  come up with names for things I don't want to actually bind,
                </li>
                <li>duplicate the names of things unnecessarily, or</li>
                <li>
                  separate the types of things from the places where I bind
                  them.
                </li>
              </ul>
            </li>
          </ul>
          <h2>Comparisons</h2>
          <p>
            Let's compare this pseudocode to what we're forced to write in the
            three languages I'm most familiar with. Obviously I don't know every
            programming language, so if there exists one that does better than
            these three and checks all the boxes here (or if there's a better
            way to do it in one of these three languages), let me know!
          </p>
          <h3>Python</h3>
          <p>
            The current most popular programming language does an alright job on
            this.
          </p>
          <pre><code class="language-python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypedDict


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):
    name: <span class="hljs-built_in">str</span>
    phone: <span class="hljs-built_in">str</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Options</span>(<span class="hljs-title class_ inherited__">TypedDict</span>):
    fragile: <span class="hljs-built_in">str</span>
    window: HalfDay


<span class="hljs-keyword">def</span> <span class="hljs-title function_">transport</span>(<span class="hljs-params">
    times: <span class="hljs-built_in">tuple</span>[datetime, datetime],
    foo: FooId,
    /,
    *,
    bar: BarId,
    person: Person,
    options: Options,
</span>):
    start, end = times

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*, name, phone, fragile, window</span>):
        who = name
        do_stuff(who, foo)
        more_stuff(phone, end, window)
        other_things(start, fragile, bar)

    inner(**person, **options)


bar = something()
transport(
    (iso(<span class="hljs-string">&quot;2025-09-03T09:00:00Z&quot;</span>), iso(<span class="hljs-string">&quot;2025-09-03T11:00:00Z&quot;</span>)),
    foo123,
    bar=bar,
    person={<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alex Smith&quot;</span>, <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;+1 (555) 555-5555&quot;</span>},
    options={<span class="hljs-string">&quot;fragile&quot;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&quot;window&quot;</span>: HalfDay.PM},
)
</code></pre>
          <p>
            Python does let you pass function parameters either positionally or
            by name, without you having to do anything special. In this example
            I was a bit extra, using <code>/, *,</code> to
            <em>force</em> everything before to be positional and everything
            after to be named.
          </p>
          <p>Still, this Python code has some issues:</p>
          <ul>
            <li>
              The most minor one is that we can't destructure the
              <code>tuple</code> right away, so we need to make a variable name
              for it.
            </li>
            <li>
              There's no shorthand syntax to avoid writing a parameter name
              twice if your variable name is the same.
            </li>
            <li>
              While keyword arguments are great, they only really work for the
              outermost level of arguments to a function. This means we have to
              make a couple concessions:
              <ul>
                <li>
                  We have to make names for the <code>Person</code> and
                  <code>Options</code> types, and define their field types a bit
                  far from their corresponding parameters in the
                  <code>transport</code> function.
                </li>
                <li>
                  I'm not aware of a good way to destructure a dict unless you
                  want to do something cursed like
                  <a href="https://github.com/asottile/dict-unpacking-at-home"
                    ><code>pip install dict-unpacking-at-home</code></a
                  >. The best I'm aware of is this trick where you use unpacking
                  and keyword arguments to achieve a similar result with an
                  <code>inner</code> function. Of course, you'd have to repeat
                  this trick for each additional layer of nesting.
                </li>
                <li>
                  We can't use a variable name different from the field name
                  when destructuring.
                </li>
              </ul>
            </li>
          </ul>
          <h3>TypeScript</h3>
          <p>
            This one is definitely the closest to the pseudocode I wrote at the
            top.
          </p>
          <pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">transport</span>(<span class="hljs-params">
  [start, end]: [<span class="hljs-title class_">Timestamp</span>, <span class="hljs-title class_">Timestamp</span>],
  <span class="hljs-attr">foo</span>: <span class="hljs-title class_">FooId</span>,
  {
    bar,
    person: { name: who, phone },
    options: { fragile, <span class="hljs-variable language_">window</span> },
  }: {
    bar: BarId;
    person: { name: <span class="hljs-built_in">string</span>; phone: <span class="hljs-built_in">string</span> };
    options: { fragile: <span class="hljs-built_in">boolean</span>; <span class="hljs-variable language_">window</span>: HalfDay };
  },
</span>) {
  <span class="hljs-title function_">doStuff</span>(who, foo);
  <span class="hljs-title function_">moreStuff</span>(phone, end, <span class="hljs-variable language_">window</span>);
  <span class="hljs-title function_">otherThings</span>(start, fragile, bar);
}

<span class="hljs-keyword">let</span> bar = <span class="hljs-title function_">something</span>();
<span class="hljs-title function_">transport</span>([<span class="hljs-title function_">iso</span>(<span class="hljs-string">&quot;2025-09-03T09:00:00Z&quot;</span>), <span class="hljs-title function_">iso</span>(<span class="hljs-string">&quot;2025-09-03T11:00:00Z&quot;</span>)], foo123, {
  bar,
  <span class="hljs-attr">person</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alex Smith&quot;</span>, <span class="hljs-attr">phone</span>: <span class="hljs-string">&quot;+1 (555) 555-5555&quot;</span> },
  <span class="hljs-attr">options</span>: { <span class="hljs-attr">fragile</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">window</span>: <span class="hljs-title class_">HalfDay</span>.<span class="hljs-property">PM</span> },
});
</code></pre>
          <p>
            The only issue here is locality. Rather than being able to write the
            types for the fields and tuple elements next to the names we use for
            destructuring, we have to write them separately and duplicate all
            the field names.
          </p>
          <h3>Rust</h3>
          <p>
            This one is the worst of the three in my opinion, which is sad
            because Rust is currently my favorite programming language.
          </p>
          <pre><code class="language-rust"><span class="hljs-keyword">use</span> std::time::Instant;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; {
    name: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,
    phone: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Options</span> {
    fragile: <span class="hljs-type">bool</span>,
    window: HalfDay,
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Args</span> {
    bar: BarId,
    person: Person,
    options: Options,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">transport</span>(
    (start, end): (Instant, Instant),
    foo: FooId,
    Args {
        bar,
        person: Person { name: who, phone },
        options: Options { fragile, window },
    }: Args,
) {
    <span class="hljs-title function_ invoke__">do_stuff</span>(who, foo);
    <span class="hljs-title function_ invoke__">more_stuff</span>(phone, end, window);
    <span class="hljs-title function_ invoke__">other_things</span>(start, fragile, bar);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">bar</span> = <span class="hljs-title function_ invoke__">something</span>();
    <span class="hljs-title function_ invoke__">transport</span>(
        (<span class="hljs-title function_ invoke__">iso</span>(<span class="hljs-string">&quot;2025-09-03T09:00:00Z&quot;</span>), <span class="hljs-title function_ invoke__">iso</span>(<span class="hljs-string">&quot;2025-09-03T11:00:00Z&quot;</span>)),
        foo123,
        Args {
            bar,
            person: Person {
                name: <span class="hljs-string">&quot;Alex Smith&quot;</span>,
                phone: <span class="hljs-string">&quot;+1 (555) 555-5555&quot;</span>,
            },
            options: Options {
                fragile: <span class="hljs-literal">true</span>,
                window: HalfDay::PM,
            },
        },
    )
}
</code></pre>
          <p>
            Rust doesn't have <em>either</em>
            <a href="https://github.com/rust-lang/rfcs/issues/323"
              >keyword arguments as a first-class concept</a
            >
            like Python <em>or</em>
            <a href="https://github.com/rust-lang/rfcs/pull/2584"
              >anonymous struct types</a
            >
            like TypeScript. And unlike other systems languages like C++ or Zig,
            you can't omit the type name in a struct literal at the call site,
            so calls to functions using an approach like this in Rust are just
            too verbose.
          </p>
          <p>
            Because passing named arguments like this in Rust is so
            inconvenient, it's very common to just use positional arguments
            instead. The Rust culture of using nice specific types can help
            prevent accidentally mixing up arguments if all a function's
            argument types are different, but if some of them are the same type,
            it's just error-prone. For instance, in the
            <code>wasm-encoder</code> crate, the
            <a
              href="https://docs.rs/wasm-encoder/0.238.1/wasm_encoder/enum.Instruction.html#variant.MemoryCopy"
              >old <code>Instruction</code> API for <code>memory.copy</code></a
            >
            names the <code>src_mem</code> and <code>dst_mem</code> fields so
            you can easily see which is which at the call site; but the
            <a
              href="https://docs.rs/wasm-encoder/0.238.1/wasm_encoder/struct.InstructionSink.html#method.memory_copy"
              >new <code>InstructionSink</code> API</a
            >
            just uses positional arguments so you'd have to hover over the
            <code>memory_copy</code> memory name to see which is which. (Full
            disclosure:
            <a href="https://github.com/bytecodealliance/wasm-tools/pull/1985"
              >I wrote the new API</a
            >
            and this was a point of discussion before it got merged.)
          </p>
          <p>
            Yes, I know that rust-analyzer shows parameter names as inlay hints
            by default. No, I do not have inlay hints enabled. In my opinion,
            they make code harder to read by causing things to visually spill
            past the rustfmt column limit.
          </p>
          <h2>Representation</h2>
          <p>
            OK, so how might one implement this? I'll leave an actual parser as
            an exercise for the reader (although if you're curious, here's a
            <a
              href="https://github.com/gradbench/gradbench/blob/2f8b13ac4a65be3a71641d7d9c43d890ecf0a4f9/crates/adroit/src/parse.rs"
              >link to one I prototyped in the past</a
            >), but let's at least look at how one might represent it at the AST
            level.
          </p>
          <h3>Standard</h3>
          <p>
            Using TypeScript type definitions, here is how we might represent a
            simplified AST for a subset of legal TypeScript function signatures:
          </p>
          <pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">TypeField</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">type</span>: <span class="hljs-title class_">Type</span>;
};

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Type</span> =
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;tuple&quot;</span>; <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Type</span>[] }
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>; <span class="hljs-attr">fields</span>: <span class="hljs-title class_">TypeField</span>[] };

<span class="hljs-keyword">type</span> <span class="hljs-title class_">BindingField</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  binding?: <span class="hljs-title class_">Binding</span>;
};

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Binding</span> =
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;tuple&quot;</span>; <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Binding</span>[] }
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>; <span class="hljs-attr">fields</span>: <span class="hljs-title class_">BindingField</span>[] };

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameter</span> = {
  <span class="hljs-attr">binding</span>: <span class="hljs-title class_">Binding</span>;
  <span class="hljs-attr">type</span>: <span class="hljs-title class_">Type</span>;
};

<span class="hljs-keyword">type</span> <span class="hljs-title class_">FunctionSignature</span> = {
  <span class="hljs-attr">parameters</span>: <span class="hljs-title class_">Parameter</span>[];
  result?: <span class="hljs-title class_">Type</span>;
};
</code></pre>
          <p>
            As you can see, <code>Type</code> and <code>Binding</code> are both
            recursive types, but they're completely separate from each other.
            Then the <code>Parameter</code> type bundles together one of each.
          </p>
          <details>
            <summary>
              Expand this to see what the earlier TypeScript example would look
              like using those AST types.
            </summary>
            <pre><code class="language-javascript">{
  <span class="hljs-attr">parameters</span>: [
    {
      <span class="hljs-attr">binding</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;tuple&quot;</span>,
        <span class="hljs-attr">elements</span>: [
          { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;start&quot;</span> },
          { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;end&quot;</span> },
        ],
      },
      <span class="hljs-attr">type</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;tuple&quot;</span>,
        <span class="hljs-attr">elements</span>: [
          { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Timestamp&quot;</span> },
          { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Timestamp&quot;</span> },
        ],
      },
    },
    {
      <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span> },
      <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;FooId&quot;</span> },
    },
    {
      <span class="hljs-attr">binding</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>,
        <span class="hljs-attr">fields</span>: [
          { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bar&quot;</span> },
          {
            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;person&quot;</span>,
            <span class="hljs-attr">binding</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>,
              <span class="hljs-attr">fields</span>: [
                { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;who&quot;</span> } },
                { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;phone&quot;</span> },
              ],
            },
          },
          {
            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;options&quot;</span>,
            <span class="hljs-attr">binding</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>,
              <span class="hljs-attr">fields</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fragile&quot;</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;window&quot;</span> }],
            },
          },
        ],
      },
      <span class="hljs-attr">type</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>,
        <span class="hljs-attr">fields</span>: [
          { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;BarId&quot;</span> } },
          {
            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;person&quot;</span>,
            <span class="hljs-attr">type</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>,
              <span class="hljs-attr">fields</span>: [
                { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;string&quot;</span> } },
                { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;phone&quot;</span>, <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;string&quot;</span> } },
              ],
            },
          },
          {
            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;options&quot;</span>,
            <span class="hljs-attr">type</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>,
              <span class="hljs-attr">fields</span>: [
                { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fragile&quot;</span>, <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Boolean&quot;</span> } },
                { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;window&quot;</span>, <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;HalfDay&quot;</span> } },
              ],
            },
          },
        ],
      },
    },
  ],
}
</code></pre>
          </details>
          <h3>Proposal</h3>
          <p>
            Here's how I'd instead represent parameters and binding forms in the
            AST:
          </p>
          <pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">TypeField</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">type</span>: <span class="hljs-title class_">Type</span>;
};

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Type</span> =
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;tuple&quot;</span>; <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Type</span>[] }
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>; <span class="hljs-attr">fields</span>: <span class="hljs-title class_">TypeField</span>[] };

<span class="hljs-keyword">type</span> <span class="hljs-title class_">BindingField</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">parameter</span>: <span class="hljs-title class_">Parameter</span>;
};

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Binding</span> =
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;tuple&quot;</span>; <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Parameter</span>[] }
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>; <span class="hljs-attr">fields</span>: <span class="hljs-title class_">BindingField</span>[] };

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameter</span> = {
  <span class="hljs-attr">binding</span>: <span class="hljs-title class_">Binding</span>;
  <span class="hljs-keyword">type</span>?: <span class="hljs-title class_">Type</span>;
};

<span class="hljs-keyword">type</span> <span class="hljs-title class_">FunctionSignature</span> = {
  <span class="hljs-attr">parameter</span>: <span class="hljs-title class_">Parameter</span>;
  result?: <span class="hljs-title class_">Type</span>;
};
</code></pre>
          <p>
            We've kept <code>Type</code> (and its helper <code>TypeField</code>)
            exactly the same. There are only three differences:
          </p>
          <ul>
            <li>
              We've replaced <code>Binding</code> with <code>Parameter</code> in
              the <code>&quot;tuple&quot;</code> and
              <code>&quot;record&quot;</code> cases for <code>Binding</code>, to
              allow types to be written intermingled with destructuring.
            </li>
            <li>
              We've made the <code>type</code> field optional on
              <code>Parameter</code>, to avoid forcing types to be duplicated.
            </li>
            <li>
              We've changed the <code>FunctionSignature</code> to just have one
              <code>Parameter</code> instead of a <code>Parameter[]</code> list,
              because our ability to handle nesting means a parameter list is
              naturally handled like any other tuple.
            </li>
          </ul>
          <p>
            That last one is probably a bit too cheeky, since it makes things
            weird by having a function's parameter list be a tuple
            <em>unless</em> that tuple would have only have one element and
            there's no trailing comma. So in a real-world imperative language
            you'd probably want to keep it as an explicit
            <code>Parameter[]</code> list. But in a functional language, you
            might actually want to just use a single <code>Parameter</code>; or
            have a <code>Parameter[]</code> list but use that for currying
            instead of tuples, as is tradition.
          </p>
          <details>
            <summary>
              Expand this to see what the original pseudocode example would look
              like using these alternative AST types.
            </summary>
            <pre><code class="language-javascript">{
  <span class="hljs-attr">parameter</span>: {
    <span class="hljs-attr">binding</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;tuple&quot;</span>,
      <span class="hljs-attr">elements</span>: [
        {
          <span class="hljs-attr">binding</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;tuple&quot;</span>,
            <span class="hljs-attr">elements</span>: [
              {
                <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;start&quot;</span> },
                <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Timestamp&quot;</span> },
              },
              {
                <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;end&quot;</span> },
                <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Timestamp&quot;</span> },
              },
            ],
          },
        },
        {
          <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span> },
          <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;FooId&quot;</span> },
        },
        {
          <span class="hljs-attr">binding</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>,
            <span class="hljs-attr">fields</span>: [
              {
                <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bar&quot;</span>,
                <span class="hljs-attr">parameter</span>: {
                  <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bar&quot;</span> },
                  <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;BarId&quot;</span> },
                },
              },
              {
                <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;person&quot;</span>,
                <span class="hljs-attr">parameter</span>: {
                  <span class="hljs-attr">binding</span>: {
                    <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>,
                    <span class="hljs-attr">fields</span>: [
                      {
                        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;name&quot;</span>,
                        <span class="hljs-attr">parameter</span>: {
                          <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;who&quot;</span> },
                          <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;String&quot;</span> },
                        },
                      },
                      {
                        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;phone&quot;</span>,
                        <span class="hljs-attr">parameter</span>: {
                          <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;phone&quot;</span> },
                          <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;String&quot;</span> },
                        },
                      },
                    ],
                  },
                },
              },
              {
                <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;options&quot;</span>,
                <span class="hljs-attr">parameter</span>: {
                  <span class="hljs-attr">binding</span>: {
                    <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;record&quot;</span>,
                    <span class="hljs-attr">fields</span>: [
                      {
                        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fragile&quot;</span>,
                        <span class="hljs-attr">parameter</span>: {
                          <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fragile&quot;</span> },
                          <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Boolean&quot;</span> },
                        },
                      },
                      {
                        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;window&quot;</span>,
                        <span class="hljs-attr">parameter</span>: {
                          <span class="hljs-attr">binding</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;window&quot;</span> },
                          <span class="hljs-attr">type</span>: { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;HalfDay&quot;</span> },
                        },
                      },
                    ],
                  },
                },
              },
            ],
          },
        },
      ],
    },
  },
}
</code></pre>
          </details>
          <p>
            One quirk you can see here is that, for the common case where we
            bind a record field to a local with the same name, we only write the
            name once in the source program, but that name still ends up
            duplicated in the AST. I don't think this is really an issue, but if
            you want then you could avoid it by just inlining the definition of
            <code>Parameter</code> into the <code>BindingField</code> type and
            then making the <code>binding</code> optional there. I just didn't
            do that here because it'd make the AST types a bit less clean.
          </p>
          <h3>Checking</h3>
          <p>
            This <em>does</em> make typechecking a bit more complicated. For
            instance, what if someone writes code like this?
          </p>
          <pre><code>fn foo((x: A, y: B): (C, D)) {}
</code></pre>
          <p>
            The typechecker
            <a
              href="https://github.com/gradbench/gradbench/blob/2f8b13ac4a65be3a71641d7d9c43d890ecf0a4f9/crates/adroit/src/typecheck/mod.rs#L916-L920"
              >needs to unify</a
            >
            the type it infers from <code>binding</code> with the explicitly
            provided <code>type</code>, if there is one. And if they don't
            match, it needs to
            <a
              href="https://github.com/gradbench/gradbench/blob/2f8b13ac4a65be3a71641d7d9c43d890ecf0a4f9/crates/adroit/src/typecheck/errors/bind_disagree.adroit"
              >report an error</a
            >.
          </p>
          <p>
            Also, languages like Rust enforce the property that every top-level
            function declaration needs to provide a fully-typed signature. In my
            prototype I implemented this by just
            <a
              href="https://github.com/gradbench/gradbench/blob/2f8b13ac4a65be3a71641d7d9c43d890ecf0a4f9/crates/adroit/src/typecheck/mod.rs#L864-L876"
              >adding a <code>strict: bool</code> flag</a
            >
            to the function for typechecking parameters; not sure if there's a
            better way in general.
          </p>
          <h2>Conclusion</h2>
          <p>Some final notes just to clarify things a bit more:</p>
          <ul>
            <li>
              <p>
                While the example I showed at the top destructures
                <em>everything</em> and always colocates types with bindings,
                this syntax doesn't force you to do that. You can still keep
                types separate if you want, and/or replace <code>=</code> with
                <code>:</code> to just destructure part and then use dot syntax
                to access specific fields later. Whichever you prefer.
              </p>
              <pre><code>fn transport(
  (start, end): (Timestamp, Timestamp),
  foo: FooId,
  {
    bar: BarId,
    person: { name: String, phone: String },
    options: { fragile: Boolean, window: HalfDay },
  },
) {
  do_stuff(person.name, foo);
  more_stuff(person.phone, end, options.window);
  other_things(start, options.fragile, bar);
}
</code></pre>
            </li>
            <li>
              <p>
                This syntax isn't limited to function parameters; I think it
                makes sense to just replace <code>Binding</code> with
                <code>Parameter</code> pretty much everywhere. So, instead of
                this:
              </p>
              <pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Statement</span> =
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;expression&quot;</span>; <span class="hljs-attr">expression</span>: <span class="hljs-title class_">Expression</span> }
  <span class="hljs-comment">/* ... */</span>
  | {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;let&quot;</span>;
      <span class="hljs-attr">binding</span>: <span class="hljs-title class_">Binding</span>;
      <span class="hljs-keyword">type</span>?: <span class="hljs-title class_">Type</span>;
      <span class="hljs-attr">expression</span>: <span class="hljs-title class_">Expression</span>;
    };
</code></pre>
              <p>You'd do this:</p>
              <pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Statement</span> =
  | { <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;expression&quot;</span>; <span class="hljs-attr">expression</span>: <span class="hljs-title class_">Expression</span> }
  <span class="hljs-comment">/* ... */</span>
  | {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">&quot;let&quot;</span>;
      <span class="hljs-attr">parameter</span>: <span class="hljs-title class_">Parameter</span>;
      <span class="hljs-attr">expression</span>: <span class="hljs-title class_">Expression</span>;
    };
</code></pre>
              <p>
                And that lets you write <code>let</code> bindings in any of
                these styles:
              </p>
              <pre><code>let (x, y): (Foo, Bar) = baz();
let (x, y) = baz();
let (x: Foo, y: Bar) = baz();
let x: Foo, y: Bar = baz();
let x, y = baz();
</code></pre>
            </li>
          </ul>
          <p>Thanks for reading!</p>
        </div>
      </div>
    </main>
  </body>
</html>
