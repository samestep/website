<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/png" href="/icon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&amp;family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&amp;display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/monokai.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"
    />
    <link rel="stylesheet" href="/blog.css" />
    <title>How much slower is random access, really? | Sam Estep</title>
  </head>
  <body>
    <main>
      <h1>How much slower is random access, really?</h1>
      <p>
        <em>by <a href="/">Sam Estep</a>, unpublished</em>
      </p>
      <div>
        <p>
          I've been enjoying learning about data-oriented design (DoD) lately.
          It's exciting to dream of a future where all our compilers are faster!
        </p>
        <ul>
          <li>
            <a href="https://blog.nelhage.com/post/why-sorbet-is-fast/"
              >Sorbet</a
            >
          </li>
          <li><a href="https://youtu.be/ZI198eFghJk">Carbon</a></li>
          <li><a href="https://youtu.be/IroPQ150F6c">Zig</a></li>
          <li>Jai (I don't have a good video link for this one)</li>
        </ul>
        <p>
          When I mentioned some of these ideas with a friend, he asked
          <em>how much</em> of a difference it actually makes to access data in
          cache-friendly vs cache-unfriendly ways. He's working in the more
          theoretical context of
          <a href="https://en.wikipedia.org/wiki/Streaming_algorithm"
            >streaming algorithms</a
          >, so really he just wanted to know how justified he is in switching
          between &quot;arbitrary order&quot; and &quot;random order&quot; as
          necessary.
        </p>
        <p>
          But I realized that, while I have some high-level intuitions, and some
          of those videos I've been watching give performance numbers for whole
          pieces of software, I don't actually know what the numbers look like
          for simple programs. So let's measure!
        </p>
        <h2>Setup</h2>
        <p>
          Let's say you have an array of floating-point numbers in memory. You
          can add those numbers up in any order you like. Let's consider two
          possible orderings:
        </p>
        <ol>
          <li>First to last.</li>
          <li>Random.</li>
        </ol>
        <p>
          You won't necessarily get the same answer because
          <a href="https://walkingrandomly.com/?p=5380"
            >floating-point addition is not associative</a
          >; I kind of like that for this experiment because it means I can more
          easily trust the compiler not to do optimizations I don't expect.
        </p>
        <p>
          To specify the order, we'll just have another array that holds
          integers. That way, once we've chosen the precisions for our
          floating-point and integer data types, we should be using the
          <em>exact same machine code</em> for forward order, random order, or
          any other order we want. The performance should be entirely determined
          by <em>dynamic</em> behavior in the CPU based on the data we're using.
        </p>
        <p>
          By the way, all the code to reproduce the measurements in this blog
          post can be found in a
          <a
            href="https://github.com/samestep/random-access/tree/45ffc8fa71afefbe3a9c5e2ed68f1974335b1b25"
            >supplementary repository on GitHub</a
          >.
        </p>
        <details>
          <summary>Expand this to see some Rust code.</summary>
          <pre><code class="language-rust"><span class="hljs-keyword">use</span> std::ops::{AddAssign, Index};

<span class="hljs-keyword">use</span> num::{Float, Num, traits::ToBytes};

<span class="hljs-keyword">trait</span> <span class="hljs-title class_">Number</span>: <span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Copy</span> + <span class="hljs-built_in">Into</span>&lt;<span class="hljs-type">f64</span>&gt; + AddAssign + Num + Float + ToBytes {}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Number</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">f32</span> {}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Number</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">f64</span> {}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">sum</span>&lt;T: Number, I: <span class="hljs-built_in">Copy</span>&gt;(floats: &amp;[T], indices: &amp;[I]) <span class="hljs-punctuation">-&gt;</span> T
<span class="hljs-keyword">where</span>
    [T]: Index&lt;I, Output = T&gt;,
{
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">total</span> = T::<span class="hljs-title function_ invoke__">zero</span>();
    <span class="hljs-keyword">for</span> &amp;i <span class="hljs-keyword">in</span> indices {
        total += floats[i];
    }
    total
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_sum_f64_usize_not_associative</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">floats</span>: &amp;[<span class="hljs-type">f64</span>] = &amp;[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>];
    <span class="hljs-keyword">let</span> <span class="hljs-variable">forward</span>: &amp;[<span class="hljs-type">usize</span>] = &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
    <span class="hljs-keyword">let</span> <span class="hljs-variable">backward</span>: &amp;[<span class="hljs-type">usize</span>] = &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>];
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">sum</span>(floats, forward), <span class="hljs-number">0.6000000000000001</span>);
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">sum</span>(floats, backward), <span class="hljs-number">0.6</span>);
}
</code></pre>
        </details>
        <p>
          Now all we need to do is generate some random data. For the
          floating-point numbers we can just use a
          <a href="https://en.wikipedia.org/wiki/Normal_distribution"
            >normal distribution</a
          >, and for the integer indices we can just take the list of integers
          up to the length of our array, and
          <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"
            >shuffle</a
          >
          it to get a random order.
        </p>
        <p>
          Or rather, that's what I thought at first. Small spoiler: further down
          we're going to do some experiments with arrays too big to fit in
          memory, and for those, Fisherâ€“Yates turned out to be way too slow. So
          instead I implemented a
          <a href="https://blog.janestreet.com/how-to-shuffle-a-big-dataset/"
            >two-pass shuffle</a
          >
          which first partitions the array into chunks that are about a gigabyte
          each.
        </p>
        <details>
          <summary>Code to generate our random data.</summary>
          <pre><code class="language-rust"><span class="hljs-keyword">use</span> std::{
    fmt, fs,
    io::{<span class="hljs-keyword">self</span>, Read, Seek, Write},
};

<span class="hljs-keyword">use</span> rand::Rng;
<span class="hljs-keyword">use</span> rand_distr::{Distribution, Normal, StandardNormal};
<span class="hljs-keyword">use</span> tempfile::tempfile;

<span class="hljs-keyword">trait</span> <span class="hljs-title class_">Int</span>: TryFrom&lt;<span class="hljs-type">usize</span>, Error: fmt::<span class="hljs-built_in">Debug</span>&gt; + ToBytes {}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Int</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">u32</span> {}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Int</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">u64</span> {}

<span class="hljs-keyword">trait</span> <span class="hljs-title class_">Progress</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">step</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">random_floats</span>&lt;T: Number, P: Progress&gt;(rng: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rng</span>, <span class="hljs-keyword">mut</span> writer: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Write</span>, n: <span class="hljs-type">usize</span>)
<span class="hljs-keyword">where</span>
    StandardNormal: Distribution&lt;T&gt;,
{
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">progress</span> = P::<span class="hljs-title function_ invoke__">new</span>(n);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">normal</span> = Normal::&lt;T&gt;::<span class="hljs-title function_ invoke__">new</span>(T::<span class="hljs-title function_ invoke__">zero</span>(), T::<span class="hljs-title function_ invoke__">one</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = normal.<span class="hljs-title function_ invoke__">sample</span>(rng);
        writer.<span class="hljs-title function_ invoke__">write_all</span>(x.<span class="hljs-title function_ invoke__">to_ne_bytes</span>().<span class="hljs-title function_ invoke__">as_ref</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();
        progress.<span class="hljs-title function_ invoke__">step</span>();
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_to_last</span>&lt;I: Int, P: Progress&gt;(<span class="hljs-keyword">mut</span> writer: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Write</span>, n: <span class="hljs-type">usize</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">progress</span> = P::<span class="hljs-title function_ invoke__">new</span>(n);
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n {
        writer
            .<span class="hljs-title function_ invoke__">write_all</span>(I::<span class="hljs-title function_ invoke__">try_from</span>(i).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">to_ne_bytes</span>().<span class="hljs-title function_ invoke__">as_ref</span>())
            .<span class="hljs-title function_ invoke__">unwrap</span>();
        progress.<span class="hljs-title function_ invoke__">step</span>();
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">permutation</span>&lt;I: Int, P: Progress&gt;(rng: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rng</span>, <span class="hljs-keyword">mut</span> writer: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Write</span>, n: <span class="hljs-type">usize</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = (n * size_of::&lt;I&gt;()).<span class="hljs-title function_ invoke__">div_ceil</span>(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">progress</span> = P::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">2</span> * n);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">files</span>: <span class="hljs-type">Vec</span>&lt;fs::File&gt; = (<span class="hljs-number">0</span>..m).<span class="hljs-title function_ invoke__">map</span>(|_| <span class="hljs-title function_ invoke__">tempfile</span>().<span class="hljs-title function_ invoke__">unwrap</span>()).<span class="hljs-title function_ invoke__">collect</span>();
    {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">writers</span>: <span class="hljs-type">Vec</span>&lt;io::BufWriter&lt;_&gt;&gt; = files.<span class="hljs-title function_ invoke__">iter_mut</span>().<span class="hljs-title function_ invoke__">map</span>(io::BufWriter::new).<span class="hljs-title function_ invoke__">collect</span>();
        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = rng.<span class="hljs-title function_ invoke__">random_range</span>(<span class="hljs-number">0</span>..m);
            writers[j]
                .<span class="hljs-title function_ invoke__">write_all</span>(I::<span class="hljs-title function_ invoke__">try_from</span>(i).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">to_ne_bytes</span>().<span class="hljs-title function_ invoke__">as_ref</span>())
                .<span class="hljs-title function_ invoke__">unwrap</span>();
            progress.<span class="hljs-title function_ invoke__">step</span>();
        }
    }
    <span class="hljs-keyword">for</span> <span class="hljs-title class_">mut</span> file <span class="hljs-keyword">in</span> files {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
        file.<span class="hljs-title function_ invoke__">seek</span>(io::SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(<span class="hljs-number">0</span>)).<span class="hljs-title function_ invoke__">unwrap</span>();
        file.<span class="hljs-title function_ invoke__">read_to_end</span>(&amp;<span class="hljs-keyword">mut</span> bytes).<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-keyword">let</span> (prefix, values, suffix) = <span class="hljs-keyword">unsafe</span> { bytes.align_to_mut::&lt;I&gt;() };
        <span class="hljs-built_in">assert!</span>(prefix.<span class="hljs-title function_ invoke__">is_empty</span>());
        <span class="hljs-built_in">assert!</span>(suffix.<span class="hljs-title function_ invoke__">is_empty</span>());
        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..values.<span class="hljs-title function_ invoke__">len</span>() {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = rng.<span class="hljs-title function_ invoke__">random_range</span>(..=i);
            values.<span class="hljs-title function_ invoke__">swap</span>(i, j);
            progress.<span class="hljs-title function_ invoke__">step</span>();
        }
        writer.<span class="hljs-title function_ invoke__">write_all</span>(&amp;bytes).<span class="hljs-title function_ invoke__">unwrap</span>();
    }
}
</code></pre>
        </details>
        <p>
          Now all we need to do is use this to make a bunch of files with data
          of different sizes. We'll just do all the powers of two up whatever
          fits comfortably on our SSD.
        </p>
        <details>
          <summary>Code for bulk data generation into files.</summary>
          <pre><code class="language-rust"><span class="hljs-keyword">use</span> std::{ops::RangeInclusive, path::Path};

<span class="hljs-keyword">use</span> indicatif::ProgressBar;
<span class="hljs-keyword">use</span> rand::SeedableRng;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Progress</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">ProgressBar</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">bar</span> = ProgressBar::<span class="hljs-title function_ invoke__">new</span>(len <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>);
        bar.<span class="hljs-title function_ invoke__">set_position</span>(<span class="hljs-number">0</span>);
        bar
    }

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">step</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">inc</span>(<span class="hljs-number">1</span>);
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_rng</span>(seed: <span class="hljs-type">u64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rng</span> {
    rand_pcg::Pcg64Mcg::<span class="hljs-title function_ invoke__">seed_from_u64</span>(seed)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_file</span>(dir_name: &amp;<span class="hljs-type">str</span>, file_name: &amp;<span class="hljs-type">str</span>, f: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">FnOnce</span>(io::BufWriter&lt;fs::File&gt;)) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">dir</span> = Path::<span class="hljs-title function_ invoke__">new</span>(dir_name);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = dir.<span class="hljs-title function_ invoke__">join</span>(file_name);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;generating {}&quot;</span>, path.<span class="hljs-title function_ invoke__">display</span>());
    fs::<span class="hljs-title function_ invoke__">create_dir_all</span>(dir).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-title function_ invoke__">f</span>(io::BufWriter::<span class="hljs-title function_ invoke__">new</span>(fs::File::<span class="hljs-title function_ invoke__">create</span>(path).<span class="hljs-title function_ invoke__">unwrap</span>()));
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Options</span> {
    <span class="hljs-type">f32</span>: <span class="hljs-type">bool</span>,
    <span class="hljs-type">f64</span>: <span class="hljs-type">bool</span>,
    <span class="hljs-type">u32</span>: <span class="hljs-type">bool</span>,
    <span class="hljs-type">u64</span>: <span class="hljs-type">bool</span>,
}

<span class="hljs-keyword">const</span> FLOAT32: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;float32&quot;</span>;
<span class="hljs-keyword">const</span> FLOAT64: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;float64&quot;</span>;
<span class="hljs-keyword">const</span> UNSHUFFLED32: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;unshuffled32&quot;</span>;
<span class="hljs-keyword">const</span> SHUFFLED32: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;shuffled32&quot;</span>;
<span class="hljs-keyword">const</span> UNSHUFFLED64: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;unshuffled64&quot;</span>;
<span class="hljs-keyword">const</span> SHUFFLED64: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;shuffled64&quot;</span>;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate</span>(exponents: RangeInclusive&lt;<span class="hljs-type">usize</span>&gt;, options: Options) {
    <span class="hljs-keyword">for</span> <span class="hljs-variable">exponent</span> <span class="hljs-keyword">in</span> exponents {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-number">1</span> &lt;&lt; exponent;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;{exponent}.dat&quot;</span>);
        <span class="hljs-keyword">if</span> options.<span class="hljs-type">f32</span> {
            <span class="hljs-title function_ invoke__">generate_file</span>(FLOAT32, &amp;name, |writer| {
                random_floats::&lt;<span class="hljs-type">f32</span>, ProgressBar&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-title function_ invoke__">make_rng</span>(<span class="hljs-number">0</span>), writer, n);
            });
        }
        <span class="hljs-keyword">if</span> options.<span class="hljs-type">f64</span> {
            <span class="hljs-title function_ invoke__">generate_file</span>(FLOAT64, &amp;name, |writer| {
                random_floats::&lt;<span class="hljs-type">f64</span>, ProgressBar&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-title function_ invoke__">make_rng</span>(<span class="hljs-number">1</span>), writer, n);
            });
        }
        <span class="hljs-keyword">if</span> options.<span class="hljs-type">u32</span> {
            <span class="hljs-title function_ invoke__">generate_file</span>(UNSHUFFLED32, &amp;name, |writer| {
                first_to_last::&lt;<span class="hljs-type">u32</span>, ProgressBar&gt;(writer, n);
            });
            <span class="hljs-title function_ invoke__">generate_file</span>(SHUFFLED32, &amp;name, |writer| {
                permutation::&lt;<span class="hljs-type">u32</span>, ProgressBar&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-title function_ invoke__">make_rng</span>(<span class="hljs-number">2</span>), writer, n);
            });
        }
        <span class="hljs-keyword">if</span> options.<span class="hljs-type">u64</span> {
            <span class="hljs-title function_ invoke__">generate_file</span>(UNSHUFFLED64, &amp;name, |writer| {
                first_to_last::&lt;<span class="hljs-type">u64</span>, ProgressBar&gt;(writer, n);
            });
            <span class="hljs-title function_ invoke__">generate_file</span>(SHUFFLED64, &amp;name, |writer| {
                permutation::&lt;<span class="hljs-type">u64</span>, ProgressBar&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-title function_ invoke__">make_rng</span>(<span class="hljs-number">3</span>), writer, n);
            });
        }
    }
}
</code></pre>
        </details>
        <h2>Results</h2>
        <p>
          Alrighty, now that we have all these files, let's finally run our code
          on them!
        </p>
        <details>
          <summary>Code to calculate sums of our generated data.</summary>
          <pre><code class="language-rust"><span class="hljs-keyword">use</span> std::time::Instant;

<span class="hljs-keyword">use</span> serde::Serialize;

<span class="hljs-meta">#[derive(Serialize)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Measurement</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; {
    floats: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,
    indices: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,
    exponent: <span class="hljs-type">usize</span>,
    iteration: <span class="hljs-type">usize</span>,
    output: <span class="hljs-type">f64</span>,
    seconds: <span class="hljs-type">f64</span>,
}

<span class="hljs-meta">#[derive(Clone, Copy)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Index32</span>(<span class="hljs-type">u32</span>);

<span class="hljs-meta">#[derive(Clone, Copy)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Index64</span>(<span class="hljs-type">u64</span>);

<span class="hljs-keyword">impl</span>&lt;T&gt; Index&lt;Index32&gt; <span class="hljs-keyword">for</span> [T] {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = T;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">index</span>(&amp;<span class="hljs-keyword">self</span>, index: Index32) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Output {
        <span class="hljs-keyword">unsafe</span> { <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_unchecked</span>(index.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>) }
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; Index&lt;Index64&gt; <span class="hljs-keyword">for</span> [T] {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = T;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">index</span>(&amp;<span class="hljs-keyword">self</span>, index: Index64) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Output {
        <span class="hljs-keyword">unsafe</span> { <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_unchecked</span>(index.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>) }
    }
}

<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reinterpret</span>&lt;T&gt;(bytes: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> &amp;[T] {
    <span class="hljs-keyword">let</span> (prefix, values, suffix) = <span class="hljs-keyword">unsafe</span> { bytes.align_to::&lt;T&gt;() };
    <span class="hljs-built_in">assert!</span>(prefix.<span class="hljs-title function_ invoke__">is_empty</span>());
    <span class="hljs-built_in">assert!</span>(suffix.<span class="hljs-title function_ invoke__">is_empty</span>());
    values
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">measure_files</span>&lt;T: Number, I: <span class="hljs-built_in">Copy</span>&gt;(
    dir_floats: &amp;<span class="hljs-type">str</span>,
    dir_indices: &amp;<span class="hljs-type">str</span>,
    exponent: <span class="hljs-type">usize</span>,
    repeat: <span class="hljs-type">usize</span>,
) <span class="hljs-keyword">where</span>
    [T]: Index&lt;I, Output = T&gt;,
{
    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;{exponent}.dat&quot;</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes_floats</span> = fs::<span class="hljs-title function_ invoke__">read</span>(Path::<span class="hljs-title function_ invoke__">new</span>(dir_floats).<span class="hljs-title function_ invoke__">join</span>(&amp;name)).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes_indices</span> = fs::<span class="hljs-title function_ invoke__">read</span>(Path::<span class="hljs-title function_ invoke__">new</span>(dir_indices).<span class="hljs-title function_ invoke__">join</span>(&amp;name)).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">floats</span> = <span class="hljs-keyword">unsafe</span> { reinterpret::&lt;T&gt;(&amp;bytes_floats) };
    <span class="hljs-keyword">let</span> <span class="hljs-variable">indices</span> = <span class="hljs-keyword">unsafe</span> { reinterpret::&lt;I&gt;(&amp;bytes_indices) };
    <span class="hljs-keyword">for</span> <span class="hljs-variable">iteration</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..repeat {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = Instant::<span class="hljs-title function_ invoke__">now</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">total</span> = <span class="hljs-title function_ invoke__">sum</span>(floats, indices);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">duration</span> = start.<span class="hljs-title function_ invoke__">elapsed</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">measurement</span> = Measurement {
            floats: dir_floats,
            indices: dir_indices,
            exponent,
            iteration,
            output: total.<span class="hljs-title function_ invoke__">into</span>(),
            seconds: duration.<span class="hljs-title function_ invoke__">as_secs_f64</span>(),
        };
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, serde_json::<span class="hljs-title function_ invoke__">to_string</span>(&amp;measurement).<span class="hljs-title function_ invoke__">unwrap</span>());
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">measure</span>(exponents: RangeInclusive&lt;<span class="hljs-type">usize</span>&gt;, options: Options, repeat: <span class="hljs-type">usize</span>) {
    <span class="hljs-keyword">for</span> <span class="hljs-variable">exponent</span> <span class="hljs-keyword">in</span> exponents {
        <span class="hljs-keyword">if</span> options.<span class="hljs-type">f32</span> {
            <span class="hljs-keyword">if</span> options.<span class="hljs-type">u32</span> {
                measure_files::&lt;<span class="hljs-type">f32</span>, Index32&gt;(FLOAT32, UNSHUFFLED32, exponent, repeat);
                measure_files::&lt;<span class="hljs-type">f32</span>, Index32&gt;(FLOAT32, SHUFFLED32, exponent, repeat);
            }
            <span class="hljs-keyword">if</span> options.<span class="hljs-type">u64</span> {
                measure_files::&lt;<span class="hljs-type">f32</span>, Index64&gt;(FLOAT32, UNSHUFFLED64, exponent, repeat);
                measure_files::&lt;<span class="hljs-type">f32</span>, Index64&gt;(FLOAT32, SHUFFLED64, exponent, repeat);
            }
        }
        <span class="hljs-keyword">if</span> options.<span class="hljs-type">f64</span> {
            <span class="hljs-keyword">if</span> options.<span class="hljs-type">u32</span> {
                measure_files::&lt;<span class="hljs-type">f64</span>, Index32&gt;(FLOAT64, UNSHUFFLED32, exponent, repeat);
                measure_files::&lt;<span class="hljs-type">f64</span>, Index32&gt;(FLOAT64, SHUFFLED32, exponent, repeat);
            }
            <span class="hljs-keyword">if</span> options.<span class="hljs-type">u64</span> {
                measure_files::&lt;<span class="hljs-type">f64</span>, Index64&gt;(FLOAT64, UNSHUFFLED64, exponent, repeat);
                measure_files::&lt;<span class="hljs-type">f64</span>, Index64&gt;(FLOAT64, SHUFFLED64, exponent, repeat);
            }
        }
    }
}
</code></pre>
        </details>
        <p>And now, a chart:</p>
        <div class="svg">
          <svg viewBox="0 0 300 250" height="250">
            <polyline
              points="57.833333333333336,203.33333333333334 65.66666666666667,196.66666666666666 73.5,190 81.33333333333333,183.33333333333334 89.16666666666666,176.66666666666669 97,170 104.83333333333334,163.33333333333334 112.66666666666666,156.66666666666666 120.5,150 128.33333333333331,143.33333333333334 136.16666666666666,136.66666666666666 144,130 151.83333333333334,123.33333333333333 159.66666666666669,116.66666666666667 167.5,110 175.33333333333331,103.33333333333333 183.16666666666666,96.66666666666667 191,90 198.83333333333331,83.33333333333334 206.66666666666666,76.66666666666669 214.5,70 222.33333333333331,63.333333333333314 230.16666666666669,56.666666666666686 238,50 245.83333333333334,43.333333333333314 253.66666666666669,36.66666666666666 261.5,30 269.33333333333337,23.333333333333343 277.16666666666663,16.666666666666657 285,10"
              fill="none"
              stroke="hsl(0 100% 75%)"
              stroke-width="2"
              stroke-linejoin="round"
            ></polyline>
            <text
              x="0"
              y="105"
              fill="white"
              text-anchor="middle"
              dominant-baseline="hanging"
              transform="rotate(-90 0 105)"
            >
              time per element
            </text>
            <text
              x="45"
              y="10"
              fill="white"
              text-anchor="end"
              dominant-baseline="central"
            >
              6ns
            </text>
            <text
              x="45"
              y="43.33333333333333"
              fill="white"
              text-anchor="end"
              dominant-baseline="central"
            >
              5ns
            </text>
            <text
              x="45"
              y="76.66666666666669"
              fill="white"
              text-anchor="end"
              dominant-baseline="central"
            >
              4ns
            </text>
            <text
              x="45"
              y="110"
              fill="white"
              text-anchor="end"
              dominant-baseline="central"
            >
              3ns
            </text>
            <text
              x="45"
              y="143.33333333333337"
              fill="white"
              text-anchor="end"
              dominant-baseline="central"
            >
              2ns
            </text>
            <text
              x="45"
              y="176.66666666666666"
              fill="white"
              text-anchor="end"
              dominant-baseline="central"
            >
              1ns
            </text>
            <text
              x="45"
              y="210"
              fill="white"
              text-anchor="end"
              dominant-baseline="central"
            >
              0ns
            </text>
            <text
              x="81.33333333333333"
              y="215"
              fill="white"
              text-anchor="middle"
              dominant-baseline="hanging"
            >
              4
            </text>
            <text
              x="112.66666666666666"
              y="215"
              fill="white"
              text-anchor="middle"
              dominant-baseline="hanging"
            >
              8
            </text>
            <text
              x="144"
              y="215"
              fill="white"
              text-anchor="middle"
              dominant-baseline="hanging"
            >
              12
            </text>
            <text
              x="175.33333333333331"
              y="215"
              fill="white"
              text-anchor="middle"
              dominant-baseline="hanging"
            >
              16
            </text>
            <text
              x="206.66666666666666"
              y="215"
              fill="white"
              text-anchor="middle"
              dominant-baseline="hanging"
            >
              20
            </text>
            <text
              x="238"
              y="215"
              fill="white"
              text-anchor="middle"
              dominant-baseline="hanging"
            >
              24
            </text>
            <text
              x="269.33333333333337"
              y="215"
              fill="white"
              text-anchor="middle"
              dominant-baseline="hanging"
            >
              28
            </text>
            <text
              x="167.5"
              y="245"
              fill="white"
              text-anchor="middle"
              dominant-baseline="text-bottom"
            >
              logarithm of array length
            </text>
            <polyline
              points="50,10 50,210 285,210"
              fill="none"
              stroke="white"
              stroke-width="2"
            ></polyline>
          </svg>
        </div>
        <p>Look! It is labeled yet currently meaningless.</p>
      </div>
    </main>
  </body>
</html>
